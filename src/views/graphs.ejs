<!DOCTYPE html>
<html lang="en">
<%- include('header'); -%>

    <body>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es2015%2CIntersectionObserver"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.5.0/chart.min.js"></script>
        <script src="./chartjs-plugin.js"></script>
        <script src="./vue-color.min.js"></script>
        <div id="app">
            <%- include('navbar'); -%>
                <b-container>
                    <b-col style="white-space:nowrap">
                        <b-jumbotron header="Graphs" lead="Chart.js graphs for PPMS and SR860 Lock-in"></b-jumbotron>
                        <b-button variant="outline-danger" @click="resetGraph">Reset</b-button>
                        <b-button variant="outline-primary" v-b-toggle.control-collapse>Controls</b-button>
                        <b-button variant="outline-secondary" v-b-modal.modal-settings>Settings</b-button>
                    </b-col>
                </b-container>
                <hr class="my-4">
                <b-modal id="modal-settings" centered title="Settings">
                    <b-container fluid>
                        <b-row>
                            <b-col sm="4">
                                <label>Line Color:</label>
                            </b-col>
                            <b-col sm="8">
                                <colorpicker :color="settingOptions.lineColor" v-model="settingOptions.lineColor" />
                                <!-- <input type="color" id="color-well" name="head"> -->
                            </b-col>
                        </b-row>
                        <b-row>
                            <b-col sm="4">
                                <label>Point Color:</label>
                            </b-col>
                            <b-col sm="8">
                                <colorpicker :color="settingOptions.pointColor" v-model="settingOptions.pointColor" />
                                <!-- <input type="color" id="color-well" name="head"> -->
                            </b-col>
                        </b-row>
                        <b-row>
                            <b-col sm="4">
                                <label>Line Width:</label>
                            </b-col>
                            <b-col sm="8">
                                <b-form-input v-model="settingOptions.lineWidth" :type='number'></b-form-input>
                            </b-col>
                        </b-row>
                        <b-row>
                            <b-col sm="4">
                                <label>Point Radius:</label>
                            </b-col>
                            <b-col sm="8">
                                <b-form-input v-model="settingOptions.pointRadius" :type='number'></b-form-input>
                            </b-col>
                        </b-row>
                        <b-row>
                            <b-col sm="4">
                                <label>Line Style:</label>
                            </b-col>
                            <b-col sm="8">
                                <b-form-checkbox-group id="checkbox-group-1" v-model="settingOptions.lineStyle"
                                    :options="lineStyleOptions"></b-form-checkbox-group>
                            </b-col>
                        </b-row>
                        <b-row>
                            <b-col sm="4">
                                <label>Point Style:</label>
                            </b-col>
                            <b-col sm="8">
                                <div>
                                    <b-form-select v-model="settingOptions.pointStyle" :options="pointStyleOptions">
                                    </b-form-select>
                                </div>
                            </b-col>
                        </b-row>
                    </b-container>
                    <template #modal-footer="{ ok, cancel, hide }">
                        <!-- Emulate built in modal footer ok and cancel button actions -->
                        <b-button size="sm" variant="outline-primary" @click="saveOptions">
                            Save
                        </b-button>
                        <b-button size="sm" variant="success" @click="updateOptions(); ok();">
                            OK
                        </b-button>
                        <b-button size="sm" variant="danger" @click="cancel()">
                            Cancel
                        </b-button>
                    </template>
                </b-modal>
                <b-collapse id="control-collapse">
                    <b-container class="data-row">
                        <b-row class="text-center">
                            <b-col style="white-space:nowrap">
                                <h5>Chart 1</h5>
                                <b-form-select v-model="chartOptions[0].selectedX" :options="chartOptions[0].optionsX"
                                    @change="updateGraph"></b-form-select>
                                <b-form-select v-model="chartOptions[0].selectedY" :options="chartOptions[0].optionsY"
                                    @change="updateGraph"></b-form-select>
                                <b-button size="sm" @click="resetZoom(0)">üè†</b-button>
                                <b-col style="white-space:nowrap">
                                    <h5>Chart 2</h5>
                                    <b-form-select v-model="chartOptions[1].selectedX"
                                        :options="chartOptions[1].optionsX" @change="updateGraph"></b-form-select>
                                    <b-form-select v-model="chartOptions[1].selectedY"
                                        :options="chartOptions[1].optionsY" @change="updateGraph"></b-form-select>
                                    <b-button size="sm" @click="resetZoom(1)">üè†</b-button>
                                </b-col>
                                <b-col style="white-space:nowrap">
                                    <h5>Chart 3</h5>
                                    <b-form-select v-model="chartOptions[2].selectedX"
                                        :options="chartOptions[2].optionsX" @change="updateGraph"></b-form-select>
                                    <b-form-select v-model="chartOptions[2].selectedY"
                                        :options="chartOptions[2].optionsY" @change="updateGraph"></b-form-select>
                                    <b-button size="sm" @click="resetZoom(2)">üè†</b-button>
                                </b-col>
                                <b-col style="white-space:nowrap">
                                    <h5>Chart 4</h5>
                                    <b-form-select v-model="chartOptions[3].selectedX"
                                        :options="chartOptions[3].optionsX" @change="updateGraph"></b-form-select>
                                    <b-form-select v-model="chartOptions[3].selectedY"
                                        :options="chartOptions[3].optionsY" @change="updateGraph"></b-form-select>
                                    <b-button size="sm" @click="resetZoom(3)">üè†</b-button>
                                </b-col>
                        </b-row>
                    </b-container>
                </b-collapse>
                <charts></charts>
                <div>
                    <h2 style=" text-align: left; display: inline-block; width: 75%;  margin-left: 3%;">
                        Log</h2>
                    <div style=" float: right; margin-right: 3%;">
                        <b-button @click="resetLog" variant="outline-warning">Clear</b-button>
                    </div>
                </div>
                <div style=" float: left; margin-left: 3%;">
                    <ul style="list-style-type:none;" id='messages'></ul>
                </div>


        </div>
        <script>
            function checkResetData(data) {
                // prevData = JSON.parse(sessionStorage.streamData)
                if (data.length > 500) {
                    resetGraph = [true, true, true, true];
                    // sessionStorage.streamData = JSON.stringify([]);
                    socket.emit('reset-stream-data');
                    // prevData = JSON.parse(sessionStorage.streamData);
                    // sessionStorage.cnt = '0';
                }
                // data['time'] = parseInt(sessionStorage.cnt);
                // prevData.push(data);
                // sessionStorage.streamData = JSON.stringify(prevData);
            }

            function instantiateChartOptions() {
                var chart_opt = []
                for (var i in [...Array(4).keys()]) {
                    chart_opt.push(new Object({
                        selectedX: null,
                        selectedY: null,
                        optionsX: [{ value: null, text: 'Select X Axis' }].concat(graphOptions.map(function (e) { return { value: e, text: e } })),
                        optionsY: [{ value: null, text: 'Select Y Axis' }].concat(graphOptions.map(function (e) { return { value: e, text: e } }))
                    }))
                }
                chart_opt[0].selectedX = 'time';
                chart_opt[0].selectedY = 'temp';
                chart_opt[1].selectedX = 'time';
                chart_opt[1].selectedY = 'field';
                return chart_opt
            }

            function renderGraph(chart, dataDict, axisX, axisY, chart_index) {
                // dataDict = JSON.parse(dataDictStr);

                chart.data.datasets[0].data = dataDict;
                chart.options.parsing.xAxisKey = axisX;
                chart.options.parsing.yAxisKey = axisY;
                chart.options.scales.y.title.text = axisY;
                chart.options.scales.x.title.text = axisX;

                // specific options for axisX = time
                if (axisX === 'time') {
                    chart.options.showLine = true;
                    if (resetGraph[chart_index] === true) {
                        chart.options.scales.x.max = 1;
                        resetGraph[chart_index] = false;
                    } else {
                        if (dataDict.length > 1) {
                            chart.options.scales.x.max = dataDict.length - 1;
                        }

                    }
                } else {
                    chart.options.scales.x.max = null;
                    chart.options.showLine = false;
                }
                chart.update();
            }

            function renderGraphOptions(chart, chartOptions) {
                chart.options.elements.line.borderColor = chartOptions["lineColor"];
                chart.options.elements.line.borderWidth = chartOptions["lineWidth"];
                chart.options.elements.point.backgroundColor = chartOptions["pointColor"];
                chart.options.elements.point.radius = chartOptions["pointRadius"];
                chart.options.elements.point.pointStyle = chartOptions["pointStyle"];
                chart.options.elements.line.fill = chartOptions["lineStyle"].includes("filled");
                if (chartOptions["lineStyle"].includes("dashed")) {
                    chart.options.elements.line.borderDash = [5, 5];
                } else {
                    chart.options.elements.line.borderDash = [0, 0];
                }
                chart.update();
            }

            socket.on('datapacket', function (data) {
                if (data != null) {
                    checkResetData(data);
                    for (var i in [...Array(4).keys()]) {
                        window.app.updateGraph(i, data);
                    }
                }
            })

            // socket.on('data', function (data) {
            //     if (data != null) {
            //         storeData(data);
            //         for (var i in [...Array(4).keys()]) {
            //             window.app.updateGraph(i);
            //         }
            //         if (JSON.parse(sessionStorage.recording)) {
            //             socket.emit("datapacket", JSON.parse(sessionStorage.streamData))
            //         }
            //         sessionStorage.cnt = (parseInt(sessionStorage.cnt) + 1).toString();
            //     }
            // })

            socket.on('started-recording', function (id) {
                sessionStorage.objectID = id;
                sessionStorage.recording = 'true';
                t = window.app.time.split(":");
                window.app.log(`Recording data for ${t[0]} hour(s) ${t[1]} minute(s) ${t[2]} second(s)`);
            })

            socket.on('stopped-recording', function (opt) {
                if (opt == 1) {
                    sessionStorage.recording = 'false';
                    window.app.log('Stopped Recording...')
                }
                else {
                    sessionStorage.recording = 'false';
                    window.app.log('Finished Recording')
                }
            })

        </script>
        <script>
            Vue.component("charts", {
                template: `
        <div>
        <div id="chart-container1" style="height:20%;  padding:15px">
            <div style="float: left;   width: 45%; padding:10px; margin-left: 40px;">
                <canvas id="myChart0"></canvas>
            </div>
            <div style="float: right;   width: 45%; padding:10px; margin-right: 40px;">
                <canvas id="myChart1"></canvas>
            </div>
        </div>
        <div id="chart-container2" style="height:20%;  padding:15px">
            <div style="float: left;   width: 45%; padding:10px; margin-left: 40px;">
                <canvas id="myChart2"></canvas>
            </div>
            <div style="float: right;   width: 45%; padding:10px; margin-right: 40px;">
                <canvas id="myChart3"></canvas>
            </div>
        </div>
        </div>`,
                methods: {
                    draw: function (options) {
                        var defaultOptions = JSON.parse(options);
                        for (var i in [...Array(4).keys()]) {
                            var ctx = document.getElementById('myChart' + i).getContext('2d');
                            var myChart = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    datasets: [{
                                        data: [],
                                    }],
                                },
                                options: {
                                    elements: {
                                        line: {

                                        },
                                        point: {

                                        }
                                    },
                                    showLine: false,
                                    scales: {
                                        y: {
                                            title: {
                                                display: true
                                            }
                                        },
                                        x: {
                                            type: 'linear',
                                            title: {
                                                display: true
                                            },
                                            position: 'bottom',
                                        }
                                    },
                                    plugins: {
                                        legend: {
                                            display: false
                                        },
                                        title: {
                                            display: true,
                                            text: 'Chart ' + (parseInt(i) + 1),
                                            padding: {
                                                top: 10,
                                                bottom: 30
                                            }
                                        },
                                        zoom: {
                                            pan: {
                                                enabled: true,
                                            },
                                            zoom: {
                                                wheel: {
                                                    enabled: true,
                                                },
                                                pinch: {
                                                    enabled: true
                                                },
                                                mode: 'xy',
                                            }
                                        }
                                    },
                                    parsing: {
                                        xAxisKey: 'time',
                                        yAxisKey: 'temp'
                                    }
                                },
                            });
                            renderGraphOptions(myChart, defaultOptions);
                            this.chartArray.push(myChart)
                        }
                    },
                },
                mounted() {
                    this.draw(sessionStorage.settingOptions);
                    globalChartArray = this.chartArray;
                },
                data() {
                    return {
                        chartArray: []
                    }
                }

            });

            var Chrome = VueColor.Chrome;
            Vue.component('colorpicker', {
                components: {
                    'chrome-picker': Chrome,
                },
                template: `
            <div class="input-group color-picker" ref="colorpicker">
                <input type="text" class="form-control" v-model="colorValue" @focus="showPicker()" @input="updateFromInput" />
                <span class="input-group-addon color-picker-container">
                    <span class="current-color" style="display: inline-block; width:35px; height: 35px; background-color: #000;
                cursor: pointer;" :style="'background-color: ' + colorValue" @click="togglePicker()"></span>
                    <chrome-picker :value="colors" @input="updateFromPicker" v-if="displayPicker" />
                </span>
            </div>`,
                props: ['color'],
                data() {
                    return {
                        colors: {
                            hex: '#000000',
                        },
                        colorValue: '',
                        displayPicker: false,
                    }
                },
                mounted() {
                    this.setColor(this.color || '#000000');
                },
                methods: {
                    setColor(color) {
                        this.updateColors(color);
                        this.colorValue = color;
                    },
                    updateColors(color) {
                        if (color.slice(0, 1) == '#') {
                            this.colors = {
                                hex: color
                            };
                        } else if (color.slice(0, 4) == 'rgba') {
                            var rgba = color.replace(/^rgba?\(|\s+|\)$/g, '').split(','),
                                hex = '#' + ((1 << 24) + (parseInt(rgba[0]) << 16) + (parseInt(rgba[1]) << 8) + parseInt(rgba[2])).toString(16).slice(1);
                            this.colors = {
                                hex: hex,
                                a: rgba[3],
                            }
                        }
                    },
                    showPicker() {
                        document.addEventListener('click', this.documentClick);
                        this.displayPicker = true;
                    },
                    hidePicker() {
                        document.removeEventListener('click', this.documentClick);
                        this.displayPicker = false;
                    },
                    togglePicker() {
                        this.displayPicker ? this.hidePicker() : this.showPicker();
                    },
                    updateFromInput() {
                        this.updateColors(this.colorValue);
                    },
                    updateFromPicker(color) {
                        this.colors = color;
                        if (color.rgba.a == 1) {
                            this.colorValue = color.hex;
                        } else {
                            this.colorValue = 'rgba(' + color.rgba.r + ', ' + color.rgba.g + ', ' + color.rgba.b + ', ' + color.rgba.a + ')';
                        }
                    },
                    documentClick(e) {
                        var el = this.$refs.colorpicker,
                            target = e.target;
                        if (el !== target && !el.contains(target)) {
                            this.hidePicker()
                        }
                    }
                },
                watch: {
                    colorValue(val) {
                        if (val) {
                            this.updateColors(val);
                            this.$emit('input', val);
                            //document.body.style.background = val;
                        }
                    }
                },
            });
            window.app = new Vue({
                el: '#app',
                mounted: function () {
                    var d = document.getElementById("messages");
                    d.outerHTML = sessionStorage.logHtml;
                },
                methods: {
                    updateGraph(chart_ind, jsondata) {
                        // check if chartOptions has been instantiated
                        if (this.chartOptions[chart_ind] != undefined) {
                            if (this.chartOptions[chart_ind].selectedX != null && this.chartOptions[chart_ind].selectedY != null) {
                                renderGraph(globalChartArray[chart_ind], jsondata, this.chartOptions[chart_ind].selectedX, this.chartOptions[chart_ind].selectedY, chart_ind);
                            }
                        }
                    },
                    resetGraph() {
                        resetGraph = [true, true, true, true];
                        socket.emit("reset-stream-data");
                    },
                    resetZoom(index) {
                        globalChartArray[index].resetZoom();
                        if (this.chartOptions[index].selectedX === 'time') {
                            globalChartArray[index].options.scales.x.min = 0;
                            globalChartArray[index].update();
                        }
                    },
                    saveOptions() {
                        sessionStorage.settingOptions = JSON.stringify(this.settingOptions);
                    },
                    updateOptions() {
                        var settingOptions = JSON.parse(sessionStorage.settingOptions);
                        globalChartArray.forEach(function (chart) {
                            renderGraphOptions(chart, settingOptions);
                        });
                    },
                    log(message) {
                        var item = document.createElement('li');
                        const now = new Date();
                        item.textContent = ['[', now.toUTCString(), '] ', message].join('');
                        messages.appendChild(item);
                        sessionStorage.logHtml = document.getElementById("messages").outerHTML;
                    },
                    resetLog() {
                        sessionStorage.setItem('logHtml', "<ul id=\'messages\' style=\'list-style-type: none;\'></ul>");
                        var d = document.getElementById("messages");
                        d.outerHTML = sessionStorage.logHtml;
                    },
                },
                data: {
                    number: 'number',
                    chartOptions: instantiateChartOptions(),
                    lineStyleOptions: ['dashed', 'filled'],
                    pointStyleOptions: ['circle', 'rect', 'rectRot', 'triangle'],
                    settingOptions: {
                        lineColor: '#B34E4F',
                        pointColor: '#E56465',
                        lineWidth: 3,
                        pointRadius: 5,
                        lineStyle: [],
                        pointStyle: 'circle'
                    },

                },
                computed: {
                    showAlert() {
                        return this.name.length > 4 ? true : false
                    }
                }
            })
        </script>
    </body>

</html>