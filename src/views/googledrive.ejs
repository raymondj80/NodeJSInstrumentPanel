<script src="https://unpkg.com/vue@latest/dist/vue.js"></script>
<script src="https://unpkg.com/bootstrap-vue@latest/dist/bootstrap-vue.js"></script>
<script src='/socket.io/socket.io.js'></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jsrender/0.9.90/jsrender.min.js"></script>
<script type="text/javascript" src="https://apis.google.com/js/api.js?onload=loadPicker"></script>

<script>
    var developerKey = 'AIzaSyDWpKfzB9fTS16iTBg0FqT7_kRr0fq0rRI';
    var clientId = '869904555675-kpje9fhnaoncru44ekg1ucgnvsa5cjlm.apps.googleusercontent.com';
    var appId = '869904555675';
    var scope = [
        'https://www.googleapis.com/auth/drive'
    ];
    var pickerApiLoaded = false;
    var oauthToken;
    var socket = io();
    var graphData;
    const graphOptions = ['time', 'temp', 'field', 'Vx1', 'Vy1', 'freq1', 'Vx2', 'Vy2', 'freq2'];

    // Use the Google API Loader script to load the google.picker script.
    function loadPicker() {
        gapi.load('auth', { 'callback': onAuthApiLoad });
        gapi.load('picker', { 'callback': onPickerApiLoad });
    }

    function onAuthApiLoad() {
        window.gapi.auth.authorize({
            'client_id': clientId,
            'scope': scope,
            'immediate': false
        },
            handleAuthResult);
    }

    function onPickerApiLoad() {
        pickerApiLoaded = true;
        createPicker();
    }

    function handleAuthResult(authResult) {
        if (authResult && !authResult.error) {
            oauthToken = authResult.access_token;
            socket.emit('token', authResult);
            createPicker();
        }
    }

    // Create and render a Picker object for searching images.
    function createPicker() {
        if (pickerApiLoaded && oauthToken) {
            var docs_view = new google.picker.DocsView(google.picker.ViewId.FOLDERS)
                .setIncludeFolders(true)
                .setSelectFolderEnabled(true)
            var picker = new google.picker.PickerBuilder()
                .enableFeature(google.picker.Feature.NAV_HIDDEN)
                .enableFeature(google.picker.Feature.MULTISELECT_ENABLED)
                .setAppId(appId)
                .setOAuthToken(oauthToken)
                .setTitle('Select Folder')
                .addView(docs_view)
                .setDeveloperKey(developerKey)
                .setCallback(pickerCallback)
                .build();
            picker.setVisible(true);
        }
    }

        // callback implementation.
    function pickerCallback(data) {
        if (data.action == google.picker.Action.PICKED) {
            window.app.folderid = data.docs[0].id;
            socket.emit('export', [window.app.filename, window.app.folderid]);
        }
    }

        // function parseData(jsondata, dataDict) {
        //     jsondata.forEach(dict => {
        //         for (const s of Object.keys(graphData)) {
        //             dataDict[s].push(dict[s]);
        //         }

        //     })
        //     dataDict.time = [...Array(dataDict.temp.length).keys()];
        //     return dataDict;
        // }


    function renderGraph(chart, mongoData, axisX, axisY, chartOptions) {
        chart.data.datasets[0].data = mongoData;
        chart.options.parsing.xAxisKey = axisX;
        chart.options.parsing.yAxisKey = axisY;
        chart.options.scales.y.title.text = axisY;
        chart.options.scales.x.title.text = axisX;
        if (axisX === 'time') {
            chart.options.showLine = true;
        }
        chart.options.elements.line.borderColor = chartOptions["lineColor"];
        chart.options.elements.line.borderWidth = chartOptions["lineWidth"];
        chart.options.elements.point.backgroundColor = chartOptions["pointColor"];
        chart.options.elements.point.radius = chartOptions["pointRadius"];
        chart.options.elements.point.pointStyle = chartOptions["pointStyle"];
        chart.options.elements.line.fill = chartOptions["lineStyle"].includes("filled");
        if (chartOptions["lineStyle"].includes("dashed")) {
            chart.options.elements.line.borderDash = [5, 5];
        } else {
            chart.options.elements.line.borderDash = [0, 0];
        }
        chart.update();
    }


    socket.on("fileuploaded", function (data) {
        console.log('fileuploaded');
        window.app.toggleVueAlert();
    })

    socket.on("mongoData", function (data) {
        var settingOptions = JSON.parse(sessionStorage.settingOptions);
        console.log(data);
        graphData = data;
        renderGraph(myChart, graphData, window.app.selectedX, window.app.selectedY, settingOptions);
    })
</script>

<div id="app" class="app">
    <b-navbar toggleable="lg" type="dark" variant="dark">
        <b-collapse id="nav-collapse" is-nav>
            <b-navbar-nav>
                <b-nav-item href="/home">Home</b-nav-item>
                <b-nav-item href="/graphs">Graphs</b-nav-item>
                <b-nav-item href="/gd">Google Drive</b-nav-item>
            </b-navbar-nav>

            <!-- Right aligned nav items -->
            <b-navbar-nav class="ml-auto">
                <b-nav-item-dropdown right>
                    <template #button-content>
                        <em>
                            <%= name %>
                        </em>
                    </template>
                    <b-nav-item @click="logout">Sign Out</b-nav-item>
                </b-nav-item-dropdown>
            </b-navbar-nav>
        </b-collapse>
    </b-navbar>

    <b-alert :show="toggleVue" dismissible variant="success">Success Alert</b-alert>
    <b-container>
        <b-jumbotron header="GoogleDrive" lead="Save data into .csv or .dat file format">
            <hr class="my-4">
        </b-jumbotron>

        <div>
            <b-form>
                <b-input-group class="record-inputs">
                    <b-form-input id="record-filename" v-model="filename" type="text" placeholder="filename"
                        required></b-form-input>
                    <b-input-group-append>
                        <b-button @click="onExport" variant="outline-primary">Export</b-button>
                </b-input-group>
            </b-form>
        </div>

        <b-form-file
            multiple :file-name-formatter="formatNames"
        ></b-form-file>



        <div style="display: inline-block;">
            <b-form-select v-model="selectedX" :options="optionsX" @change="updateGraph"></b-form-select>
            <b-form-select v-model="selectedY" :options="optionsY" @change="updateGraph"></b-form-select>
        </div>
    </b-container>
</div>
<div class="chart-container"
        style="margin-left: 100px; display: flex; justify-content: center; height:40vh; width:80vw">
        <canvas id="myChart"></canvas>
</div>

<script type="module">
        import Multiselect from 'vue-multiselect'

        // register globally
        Vue.component('multiselect', Multiselect)

        export default {
        // OR register locally
        components: { Multiselect },
        data () {
            return {
            value: null,
            options: ['list', 'of', 'options']
            }
        }
        }
</script>

<script>
    var ctx = document.getElementById('myChart').getContext('2d');
    var myChart = new Chart(ctx, {
        type: 'line',
        data: {
            datasets: [{
                data: [],
            }],
        },
        options: {
            elements: {
                line: {

                },
                point: {

                }
            },
            showLine: false,
            scales: {
                y: {
                    title: {
                        display: true
                    }
                },
                x: {
                    type: 'linear',
                    title: {
                        display: true
                    },
                    position: 'bottom',
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                title: {
                    display: true,
                    // text: 'Chart ' + (parseInt(i) + 1),
                    padding: {
                        top: 10,
                        bottom: 30
                    }
                },
                // zoom: {
                //     pan: {
                //         enabled: true,
                //     },
                //     zoom: {
                //         wheel: {
                //             enabled: true,
                //         },
                //         pinch: {
                //             enabled: true
                //         },
                //         mode: 'xy',
                //     }
                // }
            },
            parsing: {
                xAxisKey: 'time',
                yAxisKey: 'temp'
            }
        },
    });
</script>
<script>
    window.app = new Vue({
        el: '#app',
        mounted() {

        },
        data: {
            name: '',
            filename: '',
            folderid: '',
            toggleVue: false,
            selectedX: 'time',
            selectedY: 'temp',
            optionsX: [{ value: null, text: 'Select X Axis' }].concat(graphOptions.map(function (e) { return { value: e, text: e } })),
            optionsY: [{ value: null, text: 'Select Y Axis' }].concat(graphOptions.map(function (e) { return { value: e, text: e } }))
        },
        methods: {
            formatNames(files) {
                console.log(files);
                return files.length === 1 ? files[0].name : `${files.length} files selected`;
            },
            onExport(event) {
                event.preventDefault();
                loadPicker();
            },
            toggleVueAlert() {
                this.toggleVue = !this.toggleVue;
            },
            updateGraph() {
                if (this.selectedX != null && this.selectedY != null) {
                    var settingOptions = JSON.parse(sessionStorage.settingOptions);
                    renderGraph(myChart, graphData, this.selectedX, this.selectedY, settingOptions);
                }
            },
        },
        computed: {
            showAlert() {
                return this.name.length > 4 ? true : false
            }
        }
    })
</script>